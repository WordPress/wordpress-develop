{"version":3,"names":["useRegistry","cachedParsers","WeakMap","useParsePatternDependencies","registry","has","deps","Map","set","parsePatternDependencies","bind","get","name","blocks","queue","length","block","shift","innerBlock","_block$innerBlocks","innerBlocks","unshift","registerDependency","attributes","slug","a","b","Set","add","hasCycle","TypeError","visitedNodes","currentPath","_deps$get","dependencies","dependency","delete"],"sources":["@wordpress/block-library/src/pattern/recursion-detector.js"],"sourcesContent":["/**\n * THIS MODULE IS INTENTIONALLY KEPT WITHIN THE PATTERN BLOCK'S SOURCE.\n *\n * This is because this approach for preventing infinite loops due to\n * recursively rendering blocks is specific to the way that the `core/pattern`\n * block behaves in the editor. Any other block types that deal with recursion\n * SHOULD USE THE STANDARD METHOD for avoiding loops:\n *\n * @see https://github.com/WordPress/gutenberg/pull/31455\n * @see packages/block-editor/src/components/recursion-provider/README.md\n */\n\n/**\n * WordPress dependencies\n */\nimport { useRegistry } from '@wordpress/data';\n\n/**\n * Naming is hard.\n *\n * @see useParsePatternDependencies\n *\n * @type {WeakMap<Object, Function>}\n */\nconst cachedParsers = new WeakMap();\n\n/**\n * Hook used by PatternEdit to parse block patterns. It returns a function that\n * takes a pattern and returns nothing but throws an error if the pattern is\n * recursive.\n *\n * @example\n * ```js\n * const parsePatternDependencies = useParsePatternDependencies();\n * parsePatternDependencies( selectedPattern );\n * ```\n *\n * @see parsePatternDependencies\n *\n * @return {Function} A function to parse block patterns.\n */\nexport function useParsePatternDependencies() {\n\tconst registry = useRegistry();\n\n\t// Instead of caching maps, go straight to the point and cache bound\n\t// functions. Each of those functions is bound to a different Map that will\n\t// keep track of patterns in the context of the given registry.\n\tif ( ! cachedParsers.has( registry ) ) {\n\t\tconst deps = new Map();\n\t\tcachedParsers.set(\n\t\t\tregistry,\n\t\t\tparsePatternDependencies.bind( null, deps )\n\t\t);\n\t}\n\treturn cachedParsers.get( registry );\n}\n\n/**\n * Parse a given pattern and traverse its contents to detect any subsequent\n * patterns on which it may depend. Such occurrences will be added to an\n * internal dependency graph. If a circular dependency is detected, an\n * error will be thrown.\n *\n * EXPORTED FOR TESTING PURPOSES ONLY.\n *\n * @param {Map<string, Set<string>>} deps           Map of pattern dependencies.\n * @param {Object}                   pattern        Pattern.\n * @param {string}                   pattern.name   Pattern name.\n * @param {Array}                    pattern.blocks Pattern's block list.\n *\n * @throws {Error} If a circular dependency is detected.\n */\nexport function parsePatternDependencies( deps, { name, blocks } ) {\n\tconst queue = [ ...blocks ];\n\twhile ( queue.length ) {\n\t\tconst block = queue.shift();\n\t\tfor ( const innerBlock of block.innerBlocks ?? [] ) {\n\t\t\tqueue.unshift( innerBlock );\n\t\t}\n\t\tif ( block.name === 'core/pattern' ) {\n\t\t\tregisterDependency( deps, name, block.attributes.slug );\n\t\t}\n\t}\n}\n\n/**\n * Declare that pattern `a` depends on pattern `b`. If a circular\n * dependency is detected, an error will be thrown.\n *\n * EXPORTED FOR TESTING PURPOSES ONLY.\n *\n * @param {Map<string, Set<string>>} deps Map of pattern dependencies.\n * @param {string}                   a    Slug for pattern A.\n * @param {string}                   b    Slug for pattern B.\n *\n * @throws {Error} If a circular dependency is detected.\n */\nexport function registerDependency( deps, a, b ) {\n\tif ( ! deps.has( a ) ) {\n\t\tdeps.set( a, new Set() );\n\t}\n\tdeps.get( a ).add( b );\n\tif ( hasCycle( deps, a ) ) {\n\t\tthrow new TypeError(\n\t\t\t`Pattern ${ a } has a circular dependency and cannot be rendered.`\n\t\t);\n\t}\n}\n\n/**\n * Determine if a given pattern has circular dependencies on other patterns.\n * This will be determined by running a depth-first search on the current state\n * of the graph represented by `patternDependencies`.\n *\n * @param {Map<string, Set<string>>} deps           Map of pattern dependencies.\n * @param {string}                   slug           Pattern slug.\n * @param {Set<string>}              [visitedNodes] Set to track visited nodes in the graph.\n * @param {Set<string>}              [currentPath]  Set to track and backtrack graph paths.\n * @return {boolean} Whether any cycle was found.\n */\nfunction hasCycle(\n\tdeps,\n\tslug,\n\tvisitedNodes = new Set(),\n\tcurrentPath = new Set()\n) {\n\tvisitedNodes.add( slug );\n\tcurrentPath.add( slug );\n\n\tconst dependencies = deps.get( slug ) ?? new Set();\n\n\tfor ( const dependency of dependencies ) {\n\t\tif ( ! visitedNodes.has( dependency ) ) {\n\t\t\tif ( hasCycle( deps, dependency, visitedNodes, currentPath ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if ( currentPath.has( dependency ) ) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Remove the current node from the current path when backtracking\n\tcurrentPath.delete( slug );\n\treturn false;\n}\n"],"mappings":"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"}